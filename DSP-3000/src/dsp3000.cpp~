#include "ros/ros.h"
#include "std_msgs/Float32.h"
#include "cereal_port/CerealPort.h"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <sstream>

#define TIMEOUT 1000

using namespace std;

int main(int argc, char **argv)
{
  ros::init(argc, argv, "dsp3000");

  ros::NodeHandle n;

  // Grab the port name passed by the launch file.  If the launch file was not used, or the desired
  // port is not present, default to /dev/ttyUSB0.
  string port_name;
  n.param<std::string>("port", port_name, "/dev/ttyUSB0");

  // Define the publisher topic name
  ros::Publisher chatter_pub = n.advertise<std_msgs::Float32>("dsp3000", 1000);

  ros::Rate loop_rate(100);

  cereal::CerealPort device;

  char reply[64];
  float rotate;
  int valid;

  // Open a port as defined in the launch file.  If the launch 
  try{ device.open(port_name.c_str(), 38400); }
  catch(cereal::Exception& e)
  {
      ROS_FATAL("Failed to open the serial port!!!");
      ROS_BREAK();
  }
  ROS_INFO("The serial port is opened.");

  // Configure the DSP-3000.
  // Start by zeroing the sensor.  Write three times, to ensure it is received (according to datasheet)
  ROS_INFO("Zeroing the DSP-3000.");
  try{ device.write("Z", 1); }
  catch(cereal::TimeoutException& e)
    {
      ROS_ERROR("Timeout!");
    }
  try{ device.write("Z", 1); }
  catch(cereal::TimeoutException& e)
    {
      ROS_ERROR("Timeout!");
    }
  try{ device.write("Z", 1); }
  catch(cereal::TimeoutException& e)
    {
            ROS_ERROR("Timeout!");
        }

    // Set to "Rate" output.  R=Rate, A=Incremental Angle, P=Integrated Angle
    ROS_INFO("Configuring for Rate output.");
        try{ device.write("R", 1); }
        catch(cereal::TimeoutException& e)
        {
            ROS_ERROR("Timeout!");
        }
        try{ device.write("R", 1); }
        catch(cereal::TimeoutException& e)
        {
            ROS_ERROR("Timeout!");
        }
        try{ device.write("R", 1); }
        
        catch(cereal::TimeoutException& e)
        {
            ROS_ERROR("Timeout!");
        }

  //ros::Rate r(100);

  while (ros::ok())
  {
    
    // Get the reply, the last value is the timeout in ms
    try{ device.readLine(reply, TIMEOUT); }
    catch(cereal::TimeoutException& e)
    {
        ROS_ERROR("Timeout!");
    }

    string str(reply);
    string buf; // A buffer string
    stringstream ss(str); // Insert the string into a stream
    vector<string> tokens; // Create a vector to hold the words

    while (ss >> buf)
        tokens.push_back(buf);

    // Extract the data we want from the string vector.
    rotate = atof(tokens[0].c_str());
    valid = atoi(tokens[1].c_str());

    //ROS_INFO("Rotation Velocity: %f", rotate);
    //if (valid==1)
    //     ROS_INFO("Data is valid");

    //Declare the sensor message
    std_msgs::Float32 dsp_out;
    dsp_out.data = rotate;

    //Publish the joint state message
    chatter_pub.publish(dsp_out);

    ros::spinOnce();

    loop_rate.sleep();

  }

  return 0;

}
